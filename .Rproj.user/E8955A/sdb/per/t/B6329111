{
    "collab_server" : "",
    "contents" : "# .libPaths( c( .libPaths(), \"/home/fabio/R_lib/3.4\") )\n\n#install.packages(\"WGCNA\", repos = \"http://cran.us.r-project.org\", lib = \"/home/fabio/R_lib/3.4\", dependencies = TRUE)\n\n# library(WGCNA, lib.loc = \"/home/fabio/R_lib/3.4\")\nlibrary(WGCNA)\nlibrary(km2gcn)\nlibrary(sleuth)\n\noptions(stringsAsFactors = FALSE)\nenableWGCNAThreads(nThreads = 4)\n\nfile_path <- \"/home/fabio/Desktop/urgente/para_marcelo/carollus/teste_gene_local_trait/\"\nnetworkType <- \"signed\" # \"unsigned\", \"signed\", \"signed hybrid\", \"distance\".\nminModuleSize = 30;  # antonio 15 e brandão 100\n\n\ndatExpr <- read.csv(paste0(file_path, \"UCS_gene.csv\"), row.names = 1)\ntraitData = read.csv(paste0(file_path,\"trait_UCS\"), row.names = 1);\n\ndatExpr <- log2(datExpr + 1)\n\ndatExpr0 <- t(datExpr)\n\ngsg = goodSamplesGenes(datExpr0, verbose = 3); # funcao do wgcna q identifica linhas com NA e zero-variance\n\n# se true eh pq nao tem nenhuma linha a ser descartada\nif (!gsg$allOK) # se tiver q excluir ele refaz o data.frame apenas com os caras bons\n{\n    # Optionally, print the gene and sample names that were removed:\n    if (sum(!gsg$goodGenes)>0)\n        printFlush(paste(\"Removing genes:\", paste(names(datExpr0)[!gsg$goodGenes], collapse = \", \")));\n    if (sum(!gsg$goodSamples)>0)\n        printFlush(paste(\"Removing samples:\", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = \", \")));\n    # Remove the offending genes and samples from the data:\n    datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]\n}\nsampleTree = hclust(dist(datExpr0), method = \"average\"); # faz o clustering para detectar os outliers\n\npng(filename = paste0(file_path,\"sampleClustering.png\"), width=2000, height=1500, res = 300)\npar(mar = c(0,4,2,0), cex = 0.6)\nplot(sampleTree, main = \"Sample clustering to detect outliers\", sub=\"\", xlab=\"\", cex.lab = 1.5,\n     cex.axis = 1.5, cex.main = 2)\nabline(h = 265, col = \"red\"); # escolheu o 15 como outlier atraves de uma obervacao do plot\ndev.off()\n\n# se não tem outliers pule direto para linha 58\n\n# Determine cluster under the line\nclust = cutreeStatic(sampleTree, cutHeight = 265, minSize = 5) # corta a arvore em ramos definidos por ter altura acima de 15 e ramos com pelo menos 10 individuos\n\n#table(clust)\n# clust 1 contains the samples we want to keep.\nkeepSamples = (clust==1)\n# refaz o data.frame sem os outliers q foram identificados pelo hclust\ndatExpr = datExpr0[keepSamples, ]\n\nvec <- apply(datExpr, 1, function(x){\n    quantile(x = x, 0.75) > log2(10)\n})\n\n#remove residual data\ndatExpr0 <- datExpr[, vec]\n\ndatExpr = datExpr0\n\nremove(datExpr0)\ngc(verbose = FALSE)\n\n\npatient_complete_name <- rownames(datExpr)\n#get the fisrt 3 elemetns inside all the keys\npatient_partial_name <- lapply(strsplit(x = patient_complete_name,\n                                        split = \"\\\\.\", perl = TRUE), \"[\", 1:3)\n#collapse them in a vetor\npatient_partial_name <- unlist(lapply(patient_partial_name, function(x){paste0(x, collapse = \"-\")}))\nrownames(datExpr) <- patient_partial_name\n\n\ntraitRows = match(patient_partial_name, rownames(traitData))\ntraitData$days_to_death <- gsub(pattern = \"\\\\[Not Applicable\\\\]\", replacement = \"NA\", x = traitData$days_to_death, perl = TRUE)\n\ntraitData[, 1:ncol(traitData)] <- sapply(colnames(traitData), function(col){\n    as.numeric(gsub(pattern = \"\\\\[Not Available\\\\]\", replacement = \"NA\", x = traitData[, col], perl = TRUE))\n})\n\n\ndatTraits = traitData[traitRows, ]\ntraitColors = numbers2colors(datTraits, signed = TRUE)\n\nsampleTree2 = hclust(dist(datExpr), method = \"average\"); # faz o clustering para detectar os outliers\n# Converte as características fenotípicas em uma representação de cores: branco significa valor baixo, vermelho valor alto e cinza valor faltante\ntraitColors = numbers2colors(datTraits, signed = TRUE);\n# Plota o dendograma de amostras e as cores embaixo.\n# par(mar = c(0,20,0,0))\nplotDendroAndColors(sampleTree2, traitColors,\n                    groupLabels = names(datTraits),\n                    main = \"Sample dendrogram and trait heatmap\")\n\n\n# Step 2: Network construction and module detection\npowers = c(c(1:10), seq(from = 12, to=20, by=2)) # potencias para calculo da regiao livre escala\n\nsft = pickSoftThreshold(datExpr, powerVector = powers, networkType=networkType, verbose = 5)\n\n# Plot the results:\npng(filename = paste0(file_path,\"connectivity.png\"), width=2000, height=1500, res = 300)\npar(mfrow = c(1,2));\ncex1 = 0.9;\n# Scale-free topology fit index as a function of the soft-thresholding power\nplot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],\n     xlab=\"Soft Threshold (power)\",ylab=\"Scale Free Topology Model Fit,signed R^2\",type=\"n\",\n     main = paste(\"Scale independence\"));\ntext(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],\n     labels=powers,cex=cex1,col=\"red\");\n\n# this line corresponds to using an R^2 cut-off of h\nabline(h=0.9,col=\"red\") # definiu visualmente\n\n# Mean connectivity as a function of the soft-thresholding power\nplot(sft$fitIndices[,1], sft$fitIndices[,5],\n     xlab=\"Soft Threshold (power)\",ylab=\"Mean Connectivity\", type=\"n\",\n     main = paste(\"Mean connectivity\"))\ntext(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col=\"red\")\n\ndev.off()\n\n# We choose the power XX, which is the lowest power for which the scale-free topology fit index reaches 0.90.\n# mergecutheight tem varias possibilidades como 0.25 (default), 0.15 (parece ser o mais usado) e 0.1, 0.05, => VIMOS EM ALGUM LUGAR Q POWER < 10 -> mergeCutHeight = 0.25 E POWER >= 10 -> mergeCutHeight = 0.15\nnGenes = ncol(datExpr)\nnSamples = nrow(datExpr)\n\nsoftPower = 14\n\n#MATRIX DE CORRELACAO TOM ####\nadjacency = adjacency(datExpr, power = softPower, type = networkType)\nk <- softConnectivity(datExpr, power = softPower, type = networkType) # do antonio\n\npng(filename = paste0(file_path,\"softConnectivity.png\"), width=2000, height=1500, res = 300)\npar(mfrow=c(1,2))\nhist(k)\nscaleFreePlot(k, main=\"Check scale free topology\\n\")\ndev.off()\n\nremove(datExpr0)\ngc(verbose = FALSE)\n\n# checkpoint 1 ####\nmessage(\"Saving chechpoint 1, please wait...\")\nsave.image(paste0(file_path,\"checkpoint1(before_TOM).RData\"))\n\n# TOPOLOGICAL OVERLAP MATRIX\nmessage(\"starting 'TOPOLOGICAL OVERLAP MATRIX'(TOM).\\nIt takes several minutes...\")\nTOM = TOMsimilarity(adjacency, TOMType = networkType)\ndissTOM = 1 - TOM\n\nremove(adjacency)\ngc(verbose = FALSE)\n\n# Call the hierarchical clustering function TO SEE THE TOM\ngeneTree = hclust(as.dist(dissTOM), method = \"average\")\npng(filename = paste0(file_path,\"gene_treee1.png\"), width=2000, height=1500, res = 300)\n# Plot the resulting clustering tree (dendrogram)\n#(12,9)\nplot(geneTree, xlab=\"\", sub=\"\", main = \"Gene clustering on TOM-based dissimilarity\",\n     labels = FALSE, hang = 0.04)\ndev.off()\n\ngc(verbose = FALSE)\n\n# NOW IT IS NECESSARY TO PERFORM BRANCH CUTTING\n# We like large modules, so we set the minimum module size relatively high:\n# Module identification using dynamic tree cut:\ndynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,\n                            deepSplit = 2, pamRespectsDendro = FALSE,\n                            minClusterSize = minModuleSize)\n#table(dynamicMods)\nremove(dissTOM)\ngc(verbose = FALSE)\n\n\n# LISTS THE SIZE OF THE MODULES (42 MODULES WERE FOUND)\n# Convert numeric lables into colors\ndynamicColors = labels2colors(dynamicMods)\n#table(dynamicColors)\ngc(verbose = FALSE)\n# Plot the dendrogram and colors underneath\npng(filename = paste0(file_path,\"dendroandcolors.png\"), width=2000, height=1500, res = 300)\n##(8,6)\nplotDendroAndColors(geneTree, dynamicColors, \"Dynamic Tree Cut\",\n                    dendroLabels = FALSE, hang = 0.03,\n                    addGuide = TRUE, guideHang = 0.05,\n                    main = \"Gene dendrogram and module colors\")\ndev.off()\n\n\n#PARECE COMECA UMA NOVA ANALISE USANDO O DATEXPR, TO CONFUSO MAS PARECE Q DEPOIS EH FEITO UM MERGE ENTRE AS DUAS ANALISES\n# Calculate eigengenes\nMEList = moduleEigengenes(datExpr, colors = dynamicColors)\nMEs = MEList$eigengenes\n# Calculate dissimilarity of module eigengenes\nMEDiss = 1-cor(MEs, use = 'pairwise.complete.obs');\n# MEDiss = 1-cor(MEs, use = 'pairwise.complete.obs');\n# Cluster module eigengenes\nMEDiss[\"MEgrey\" == rownames(MEDiss), ] <- 0\nMETree = hclust(dist(MEDiss), method = \"average\")\n# Plot the result\npng(filename = paste0(file_path,\"MEtree.png\"), width= 10, height = 5, res = 300, units = 'in')\nplot(METree, main = \"Clustering of module eigengenes\",\n     xlab = \"\", sub = \"\")\n\n# DECIDE CORTAR A ARVORE EM 0.15 Q REPRESENTA FORMAR GRUPOS COM 0.85 DE CORRELACAO (O PLOT ACIMA EH FEITO SOBRE A DISSMILARIDADE => 1-COR)\nMEDissThres = 0.15 # antonio 0.3 e brandão 0.25\n# Plot the cut line into the dendrogram\nabline(h=MEDissThres, col = \"red\")\n# Call an automatic merging function\nmerge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)\n# The merged module colors\nmergedColors = merge$colors\n# Eigengenes of the new merged modules:\nmergedMEs = merge$newMEs\ndev.off()\n\n#PLOTA OS RESULTADOS DE AMBAS METODOLOGIAS\npng(filename = paste0(file_path,\"genedendro_0.15.png\"), width=2000, height=1500, res = 300)\nplotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),\n                    c(\"Dynamic Tree Cut\", \"Merged dynamic\"),\n                    dendroLabels = FALSE, hang = 0.03,\n                    addGuide = TRUE, guideHang = 0.05)\ndev.off()\n\n\nmoduleColors = mergedColors\n# Constrói os rótulos numéricos correspondente as cores\ncolorOrder = c(\"grey\", standardColors(50));\nmoduleLabels = match(moduleColors, colorOrder)-1;\nMEs = mergedMEs;\n\n\nbwnet = blockwiseModules(datExpr, maxBlockSize = 5000,\n                         power = softPower, TOMType = networkType, minModuleSize = minModuleSize,\n                         reassignThreshold = 0, mergeCutHeight = 0.25,\n                         numericLabels = TRUE,\n                         saveTOMs = FALSE, #or TRUE\n                         saveTOMFileBase = paste0(file_path,\"SpodopteraTOM-blockwise\"),\n                         verbose = 3)\n\n# Carregando os resultados da análise single-block\n#load(file = \"Spodoptera-02-networkConstruction-auto.RData\");\n# Re-rotulando módulos blockwise\n\nbwLabels = matchLabels(bwnet$colors, moduleLabels);\n\n# Convertendo os rótulos em cores para plotagem\nbwModuleColors = labels2colors(bwLabels)\n\n# Plotando o dendograma e o as cores dos módulos embaixo para o bloco 1 (Substituir o número do bloco que você quer plotar em bwnet$dendrograms[[X]] e bwModuleColors[bwnet$blockGenes[[X]]])\npng(filename = paste0(file_path,\"Gene dendrogram and module colors.png\"), width=2000, height=1500, res = 300)\nplotDendroAndColors(bwnet$dendrograms[[1]], bwModuleColors[bwnet$blockGenes[[1]]],\n                    \"Module colors\", main = \"Gene dendrogram and module colors in block 1\",\n                    dendroLabels = FALSE, hang = 0.03,\n                    addGuide = TRUE, guideHang = 0.05)\ndev.off()\n\npng(filename = paste0(file_path,\"Single block gene dendrogram.png\"), width=2000, height=1500, res = 300)\n#Plotar mais de um junto\nplotDendroAndColors(geneTree,\n                    cbind(moduleColors, bwModuleColors),\n                    c(\"Single block\", \"2 blocks\"),\n                    main = \"Single block gene dendrogram and module colors\",\n                    dendroLabels = FALSE, hang = 0.03,\n                    addGuide = TRUE, guideHang = 0.05)\ndev.off()\n\nsingleBlockMEs = moduleEigengenes(datExpr, moduleColors)$eigengenes;\nblockwiseMEs = moduleEigengenes(datExpr, bwModuleColors)$eigengenes;\n\nsingle2blockwise = match(names(singleBlockMEs), names(blockwiseMEs))\nsignif(diag(cor(blockwiseMEs[, single2blockwise], singleBlockMEs)), 3)\n\ngc(verbose = FALSE)\n\n# Definindo o número de genes e amostras\nnGenes = ncol(datExpr);\nnSamples = nrow(datExpr);\n# Recalcular MEs com rótulos de cores\nMEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes\nMEs = orderMEs(MEs0)\nmoduleTraitCor = cor(MEs, datTraits, use = \"p\");\nmoduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);\n\n# Mostrar correlações e seus p-valores\ntextMatrix =  paste(signif(moduleTraitCor, 2), \"\\n(\",\n                    signif(moduleTraitPvalue, 1), \")\", sep = \"\");\ndim(textMatrix) = dim(moduleTraitCor)\npng(filename = paste0(file_path,\"Module-trait relationships.png\"), width=12, height=6, res = 500, units = 'in')\n# par(mar = c(8, 4.5, 1, 1))\n# Mostrar os valores de correlação em um heatmap plot\nlabeledHeatmap(Matrix = moduleTraitCor,\n               xLabels = names(datTraits),\n               yLabels = names(MEs),\n               ySymbols = names(MEs),\n               colorLabels = FALSE,\n               colors = blueWhiteRed(50),\n               textMatrix = textMatrix,\n               setStdMargins = FALSE,\n               cex.text = 0.15,\n               zlim = c(-1,1),\n               cex.lab.y = 0.3,\n               cex.lab.x = 0.8,\n               cex.lab = 0.5, xLabelsAngle = 25,\n               naColor = \"black\",\n               main = paste(\"Module-trait relationships\"))\ndev.off()\n\n# Definir a variável Peso10dias contendo a coluna Peso10dias do datTrait\n# Peso10dias = as.data.frame(datTraits$Peso10dias);\n# names(Peso10dias) = \"Peso10d\"\n# # nomes (cores) dos módulos\n# modNames = substring(names(MEs), 3)\n#\n# geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = \"p\"));\n# MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));\n#\n# names(geneModuleMembership) = paste(\"MM\", modNames, sep=\"\");\n# names(MMPvalue) = paste(\"p.MM\", modNames, sep=\"\");\n#\n# geneTraitSignificance = as.data.frame(cor(datExpr, Peso10dias, use = \"p\"));\n# GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));\n#\n# names(geneTraitSignificance) = paste(\"GS.\", names(Peso10dias), sep=\"\");\n# names(GSPvalue) = paste(\"p.GS.\", names(Peso10dias), sep=\"\");\n#\n# module = \"greenyellow\" #########################colocar cor do módulo para o plot\n# column = match(module, modNames);\n# moduleGenes = moduleColors==module;\n#\n# par(mfrow = c(1,1));\n# verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),\n#                    abs(geneTraitSignificance[moduleGenes, 1]),\n#                    xlab = paste(\"Module Membership in\", module, \"module\"),\n#                    ylab = \"Gene significance for Peso 10 dias\",\n#                    main = paste(\"Module membership vs. gene significance\\n\"),\n#                    cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)\n#\n# #colnames(datExpr)\n# colnames(datExpr)[moduleColors==\"greenyellow\"] ##########mostra os nomes dos genes dentro de cada módulo\n\n# geneInfo0 = data.frame(EST = colnames(datExpr),\n#                        moduleColor = moduleColors,\n#                        geneTraitSignificance,\n#                        GSPvalue)\n#\n#\n# modOrder = order(-abs(cor(MEs, Peso10dias, use = \"p\")));\n# for (mod in 1:ncol(geneModuleMembership))\n# {\n#     oldNames = names(geneInfo0)\n#     geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]],\n#                            MMPvalue[, modOrder[mod]]);\n#     names(geneInfo0) = c(oldNames, paste(\"MM.\", modNames[modOrder[mod]], sep=\"\"),\n#                          paste(\"p.MM.\", modNames[modOrder[mod]], sep=\"\"))\n# }\n# geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.Peso10d));\n# geneInfo = geneInfo0[geneOrder, ]\n# write.csv(geneInfo, file = \"geneInfo.csv\")\n\n#################################################################################\n######################Exportar rede no formato para Cytoscape\n\n# Recalcular overlap topological, se necessário\n#TOM = TOMsimilarityFromExpr(datExpr, power = 10);\n# Selecionar módulos\n#modules = c(\"brown\", \"red\"); #############escolhe modulos que quer exportar para a rede\n# Selecionar módulos dos genes\ngenes = colnames(datExpr)\ninModule = is.finite(match(moduleColors, moduleColors)); ##### se quiser exportar só cores especificas, substitui o segundo modulecolors pelos modules de cima\nmodGenes = genes[inModule];\n#modGenes = annot$gene_symbol[match(modProbes, annot$substanceBXH)];\n# Selecionar o Overlap Topologico correspondente\nmodTOM = TOM[inModule, inModule];\ndimnames(modTOM) = list(modGenes, modGenes)\ngc(verbose = FALSE)\n#########modTOMSignificantes = which(modTOM>0.1)\n#####warnings()\n\n####################Genes organizados pela importância dentro do módulo\ngenes = colnames(datExpr)\nsum(is.na(genes))\n# Deve retornar 0.\n\n# Cria o dataframe de início\n# geneInfo0 = data.frame(ESTs = genes,\n#                        moduleColor = moduleColors,\n#                        geneTraitSignificance,\n#                        GSPvalue)\n# # Ordena os módulos pela sua significância para um caracter Ex: Peso 10 dias\n# modOrder = order(-abs(cor(MEs, Peso10dias, use = \"p\")));\n# # Adiciona informação de membros do módulo na ordem escolhida\n# for (mod in 1:ncol(geneModuleMembership))\n# {\n#     oldNames = names(geneInfo0)\n#     geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]],\n#                            MMPvalue[, modOrder[mod]]);\n#     names(geneInfo0) = c(oldNames, paste(\"MM.\", modNames[modOrder[mod]], sep=\"\"),\n#                          paste(\"p.MM.\", modNames[modOrder[mod]], sep=\"\"))\n# }\n# # Ordena os genes na variavel geneinfo primeiro pela cor do módulo, depois pela geneTraitSignificance\n# geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.Peso10d));\n# geneInfo = geneInfo0[geneOrder, ]\n#\n# #escreve um arquivo com os valores ordenados\n# write.csv(geneInfo, file = \"geneInfo.csv\")\n\n\n#IMPRIME APENAS OS MODULOS DE INTERESSE, TEM Q SABER QUAL COR EH\n# $ Choose interesting modules\n# intModules = c(\"grey60\", \"brown\", \"blue\", \"magenta\") # brown =>\n# for (module in intModules)\n# {\n#     # Select module probes\n#     modGenes = (moduleColors==module)\n#     # Write them into a file\n#     fileName = paste(\"LocusIDs-\", module, \".txt\", sep=\"\")\n#\n#     write.table(as.data.frame(cbind(probes,modGenes)), file = paste(file_path, fileName, sep = \"/\"),\n#                 row.names = TRUE, col.names = FALSE)\n# }\n\n\n###Step 6: exporting network\n\n#NAO PRECISA RECALCULAR ISSO, A NAO SER Q QUEIRA COMECAR A PARTIR DAQUI\n# Recalculate topological overlap\n#TOM = TOMsimilarityFromExpr(datExpr, power = softPower);\n\n# Read in the annotation file\n#annot = read.csv(file = \"GeneAnnotation.csv\");\n\n\n# SUPER IMPORTANTE PQ SOH GERA A REDE DESSE MODULO BROWN\n# Select module\nmodule = \"blue\"\n\n# Select module probes\nprobes = colnames(datExpr)\ninModule = (moduleColors==module)\nmodProbes = probes[inModule]\n# Select the corresponding Topological Overlap\nmodTOM = TOM[inModule, inModule]\ndimnames(modTOM) = list(modProbes, modProbes)\n# Export the network into an edge list file VisANT can read\n#vis = exportNetworkToVisANT(modTOM,\n#  file = paste(\"VisANTInput-\", module, \".txt\", sep=\"\"),\n#  weighted = TRUE,\n#  threshold = 0,\n#  probeToGene = data.frame(annot$substanceBXH, annot$gene_symbol) )\n\n# SUPER IMPORTANTE PQ SOH GERA A REDE DESSE MODULO BROWN e RED\n\n# Select modules => \"magenta\", \"brown\", \"blue\", \"purple\" => modulos q contem os genes de interesse\n# modules = c(\"grey60\", \"brown\", \"blue\", \"lightyellow\")\n# Select module probes\n\n#modGenes = annot$gene_symbol[match(modProbes, annot$substanceBXH)];\n\n#faz um sobconjunto da matrix TOM com apenas esses genes\n# Select the corresponding Topological Overlap\nmodTOM = TOM[inModule, inModule]\n\n#exporta para o cytoscape\ncyt = exportNetworkToCytoscape(modTOM,\n                               edgeFile = paste0(file_path, \"CytoscapeInput-edges-\", paste(module, collapse=\"-\"), \".txt\"),\n                               nodeFile = paste0(file_path, \"CytoscapeInput-nodes-\", paste(module, collapse=\"-\"), \".txt\"),\n                               weighted = TRUE,\n                               threshold = 0,#abs(0.5+(0.5*0.85))**softPower, # abs(0.5+(0.5*0.85))**14\n                               nodeNames = modProbes,\n                               nodeAttr = moduleColors[inModule])\n\ncyt = exportNetworkToCytoscape(modTOM,\n                               edgeFile = paste0(file_path, \"CytoscapeInput-edges-\",\n                                                 paste(module, collapse=\"-\"), \"with_threshold_\",\n                                                 abs(0.5+(0.5*0.85))**softPower, \".txt\"),\n                               nodeFile = paste0(file_path, \"CytoscapeInput-nodes-\",\n                                                 paste(module, collapse=\"-\"), \"with_threshold_\",\n                                                 abs(0.5+(0.5*0.85))**softPower, \".txt\"),\n                               weighted = TRUE,\n                               threshold = abs(0.5+(0.5*0.85))**softPower, # abs(0.5+(0.5*0.85))**14\n                               nodeNames = modProbes,\n                               nodeAttr = moduleColors[inModule])\n\nnetwork <- list(moduleColors=moduleColors, MEs=MEs)\n\ntry(network_km <- km2gcn::applykM2WGCNA(net.label=\"dummy\",\n                                    net.file=network,\n                                    expr.data=datExpr,\n                                    job.path = file_path,\n                                    meg=0, net.type=networkType,\n                                    plot.evolution=TRUE))\n\nfinal_modules <- data.frame(network_km$moduleColors)\n\nwrite.table(final_modules, file = paste0(file_path, 'gene_modules_km.tsv'),\n            col.names = c(\"module\"), sep = \"\\t\", quote = FALSE)\n\n\nrestGenes= (dynamicColors != \"grey\")\ndiss1=1-TOMsimilarityFromExpr(datExpr[,restGenes], power = softPower, )\n\ncolnames(diss1) =rownames(diss1) =SubGeneNames[restGenes]\nhier1=flashClust::flashClust(as.dist(diss1), method=\"average\" )\nplotDendroAndColors(hier1, dynamicColors[restGenes], \"Dynamic Tree Cut\", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = \"Gene dendrogram and module colors\")\n\n#set the diagonal of the dissimilarity to NA\ndiag(diss1) = NA;\n\n#Visualize the Tom plot. Raise the dissimilarity matrix to the power of 4 to bring out the module structure\nTOMplot(diss1, hier1, as.character(dynamicColors[restGenes]))\n\n\nmodule_colors= setdiff(unique(dynamicColors), \"grey\")\nfor (color in module_colors){\n    module=SubGeneNames[which(dynamicColors==color)]\n    write.table(module, paste(\"module_\",color, \".txt\",sep=\"\"), sep=\"\\t\", row.names=FALSE, col.names=FALSE,quote=FALSE)\n}\n\nmodule.order <- unlist(tapply(1:ncol(datExpr),as.factor(dynamicColors),I))\nm<-t(t(datExpr[,module.order])/apply(datExpr[,module.order],2,max))\nheatmap(t(m),zlim=c(0,1),col=gray.colors(100),Rowv=NA,Colv=NA,labRow=NA,scale=\"none\",RowSideColors=dynamicColors[module.order])\n\n# Quantify module similarity by eigengene correlation. Eigengenes: Module representatives\n\nMEList = moduleEigengenes(datExpr, colors = dynamicColors)\nMEs = MEList$eigengenes\nplotEigengeneNetworks(MEs, \"\", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2))\n\n\ngc(verbose = FALSE)\nmessage(\"\\nDone!\")\n\n# dissTOM =TOMdist(adjacency)\n# #hierarchical clustering\n# geneTree = flashClust::flashClust(as.dist(dissTOM),method=\"average\")\n#\n# minModuleSize = 30;\n# # Module identification using dynamic tree cut:\n# dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,\n#                             deepSplit = 2, pamRespectsDendro = FALSE,\n#                             minClusterSize = minModuleSize)\n# #table(dynamicMods)\n#\n#\n# # LISTS THE SIZE OF THE MODULES (42 MODULES WERE FOUND)\n# # Convert numeric lables into colors\n# dynamicColors = labels2colors(dynamicMods)\n#\n# diag(dissTOM) = NA\n# # Transform dissTOM with a power to enhance visibility\n# png(filename = paste0(file_path,\"TOM_plot.png\"), width=2000, height=1500, res = 300)\n# TOMplot(dissim=dissTOM^7,dendro=geneTree,colors=dynamicColors, main = \"Network heatmap plot, all genes\")\n# dev.off()\n",
    "created" : 1511886799699.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "78026357",
    "id" : "B6329111",
    "lastKnownWriteTime" : 1511925394,
    "last_content_update" : 1511925394974,
    "path" : "~/Desktop/urgente/para_marcelo/carollus/teste_gene_local_trait/com trait.R",
    "project_path" : null,
    "properties" : {
        "source_window_id" : "",
        "tempName" : "Untitled2"
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}