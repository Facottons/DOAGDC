# .libPaths( c( .libPaths(), "/home/fabio/R_lib/3.4") )

#install.packages("WGCNA", repos = "http://cran.us.r-project.org", lib = "/home/fabio/R_lib/3.4", dependencies = TRUE)

# library(WGCNA, lib.loc = "/home/fabio/R_lib/3.4")
library(WGCNA)
library(km2gcn)
library(sleuth)

options(stringsAsFactors = FALSE)
enableWGCNAThreads(nThreads = 4)

file_path <- "/home/fabio/Desktop/urgente/para_marcelo/carollus/STAD_testes/STAD_teste_gene/tumor/"

networkType <- "signed" # "unsigned", "signed", "signed hybrid", "distance".
minModuleSize = 30;  # antonio 15 e brandão 100


# datExpr <- read.csv(paste0(file_path, "UCS_gene.csv"), row.names = 1)
# traitData = read.csv(paste0(file_path,"trait_UCS"), row.names = 1);

datExpr <- read.table(paste0(file_path, "STAD_tumor_data.tsv"), row.names = 1, sep = "\t")
traitData = read.table(paste0(file_path,"trait.tsv"), row.names = 1, sep = "\t")

datExpr <- log2(datExpr + 1)

datExpr0 <- t(datExpr)

gsg = goodSamplesGenes(datExpr0, verbose = 3); # funcao do wgcna q identifica linhas com NA e zero-variance

# se true eh pq nao tem nenhuma linha a ser descartada
if (!gsg$allOK) # se tiver q excluir ele refaz o data.frame apenas com os caras bons
{
    # Optionally, print the gene and sample names that were removed:
    if (sum(!gsg$goodGenes)>0)
        printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", ")));
    if (sum(!gsg$goodSamples)>0)
        printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", ")));
    # Remove the offending genes and samples from the data:
    datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes]
}
sampleTree = hclust(dist(datExpr0), method = "average"); # faz o clustering para detectar os outliers

png(filename = paste0(file_path,"sampleClustering.png"), width=2000, height=1500, res = 300)
par(mar = c(0,4,2,0), cex = 0.6)
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5,
     cex.axis = 1.5, cex.main = 2)
cutHeight <- 300
abline(h = cutHeight, col = "red"); # escolheu o 15 como outlier atraves de uma obervacao do plot
dev.off()

# se não tem outliers pule direto para linha 58

# Determine cluster under the line
clust = cutreeStatic(sampleTree, cutHeight = cutHeight, minSize = 5) # corta a arvore em ramos definidos por ter altura acima de 15 e ramos com pelo menos 10 individuos

#table(clust)
# clust 1 contains the samples we want to keep.
keepSamples = (clust==1)
# refaz o data.frame sem os outliers q foram identificados pelo hclust
datExpr = datExpr0[keepSamples, ]

# vec <- apply(datExpr, 1, function(x){
#     quantile(x = x, 0.75) > log2(10)
# })
#
# #remove residual data
# datExpr0 <- datExpr[, vec]

# datExpr = datExpr0

remove(datExpr0)
gc(verbose = FALSE)


patient_complete_name <- rownames(datExpr)
#get the fisrt 3 elemetns inside all the keys
patient_partial_name <- lapply(strsplit(x = patient_complete_name,
                                        split = "\\.", perl = TRUE), "[", 1:3)
#collapse them in a vetor
patient_partial_name <- unlist(lapply(patient_partial_name, function(x){paste0(x, collapse = "-")}))
rownames(datExpr) <- patient_partial_name


traitRows = match(patient_partial_name, rownames(traitData))
# traitData$days_to_death <- gsub(pattern = "\\[Not Applicable\\]", replacement = "NA", x = traitData$days_to_death, perl = TRUE)

traitData[, 1:ncol(traitData)] <- sapply(colnames(traitData), function(col){
    as.numeric(gsub(pattern = "\\[Not Available\\]", replacement = "NA", x = traitData[, col], perl = TRUE))
})

traitData[, 1:ncol(traitData)] <- sapply(colnames(traitData), function(col){
    as.numeric(gsub(pattern = "\\[Not Applicable\\]", replacement = "NA", x = traitData[, col], perl = TRUE))
})

traitData[, 1:ncol(traitData)] <- sapply(colnames(traitData), function(col){
    as.numeric(traitData[, col])
})


datTraits = as.matrix(traitData[traitRows, ])
traitColors = numbers2colors(datTraits, signed = networkType, naColor = "grey")

sampleTree2 = hclust(dist(datExpr), method = "average"); # faz o clustering para detectar os outliers
# Converte as características fenotípicas em uma representação de cores: branco significa valor baixo, vermelho valor alto e cinza valor faltante
traitColors = numbers2colors(datTraits, signed = networkType, naColor = "grey");
# Plota o dendograma de amostras e as cores embaixo.
# par(mar = c(0,20,0,0))
plotDendroAndColors(sampleTree2, traitColors,
                    groupLabels = names(datTraits),
                    main = "Sample dendrogram and trait heatmap")


# Step 2: Network construction and module detection
powers = c(c(1:10), seq(from = 12, to=20, by=2)) # potencias para calculo da regiao livre escala

sft = pickSoftThreshold(datExpr, powerVector = powers, networkType=networkType, verbose = 5)

# Plot the results:
png(filename = paste0(file_path,"connectivity.png"), width=2000, height=1500, res = 300)
par(mfrow = c(1,2));
cex1 = 0.9;
# Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");

# this line corresponds to using an R^2 cut-off of h
abline(h=0.9,col="red") # definiu visualmente

# Mean connectivity as a function of the soft-thresholding power
plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")

dev.off()

# We choose the power XX, which is the lowest power for which the scale-free topology fit index reaches 0.90.
# mergecutheight tem varias possibilidades como 0.25 (default), 0.15 (parece ser o mais usado) e 0.1, 0.05, => VIMOS EM ALGUM LUGAR Q POWER < 10 -> mergeCutHeight = 0.25 E POWER >= 10 -> mergeCutHeight = 0.15
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)

softPower = 8

#MATRIX DE CORRELACAO TOM ####
adjacency = adjacency(datExpr, power = softPower, type = networkType)
k <- softConnectivity(datExpr, power = softPower, type = networkType) # do antonio

png(filename = paste0(file_path,"softConnectivity.png"), width=2000, height=1500, res = 300)
par(mfrow=c(1,2))
hist(k)
scaleFreePlot(k, main="Check scale free topology\n")
dev.off()

remove(datExpr0)
gc(verbose = FALSE)

# checkpoint 1 ####
message("Saving chechpoint 1, please wait...")
save.image(paste0(file_path,"checkpoint1(before_TOM).RData"))

# TOPOLOGICAL OVERLAP MATRIX
message("starting 'TOPOLOGICAL OVERLAP MATRIX'(TOM).\nIt takes several minutes...")
TOM = TOMsimilarity(adjacency, TOMType = networkType)
dissTOM = 1 - TOM

remove(adjacency)
gc(verbose = FALSE)

# Call the hierarchical clustering function TO SEE THE TOM
geneTree = hclust(as.dist(dissTOM), method = "average")
png(filename = paste0(file_path,"gene_treee1.png"), width=2000, height=1500, res = 300)
# Plot the resulting clustering tree (dendrogram)
#(12,9)
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity",
     labels = FALSE, hang = 0.04)
dev.off()

gc(verbose = FALSE)

# NOW IT IS NECESSARY TO PERFORM BRANCH CUTTING
# We like large modules, so we set the minimum module size relatively high:
# Module identification using dynamic tree cut:
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
                            deepSplit = 2, pamRespectsDendro = FALSE,
                            minClusterSize = minModuleSize)
#table(dynamicMods)
remove(dissTOM)
gc(verbose = FALSE)


# LISTS THE SIZE OF THE MODULES (42 MODULES WERE FOUND)
# Convert numeric lables into colors
dynamicColors = labels2colors(dynamicMods)
#table(dynamicColors)
gc(verbose = FALSE)
# Plot the dendrogram and colors underneath
png(filename = paste0(file_path,"dendroandcolors.png"), width=2000, height=1500, res = 300)
##(8,6)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05,
                    main = "Gene dendrogram and module colors")
dev.off()


#PARECE COMECA UMA NOVA ANALISE USANDO O DATEXPR, TO CONFUSO MAS PARECE Q DEPOIS EH FEITO UM MERGE ENTRE AS DUAS ANALISES
# Calculate eigengenes
MEList = moduleEigengenes(datExpr, colors = dynamicColors)
MEs = MEList$eigengenes
# Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs, use = 'pairwise.complete.obs');
# MEDiss = 1-cor(MEs, use = 'pairwise.complete.obs');
# Cluster module eigengenes
MEDiss["MEgrey" == rownames(MEDiss), ] <- 0
METree = hclust(dist(MEDiss), method = "average")
# Plot the result
png(filename = paste0(file_path,"MEtree.png"), width= 10, height = 5, res = 300, units = 'in')
plot(METree, main = "Clustering of module eigengenes",
     xlab = "", sub = "")

# DECIDE CORTAR A ARVORE EM 0.15 Q REPRESENTA FORMAR GRUPOS COM 0.85 DE CORRELACAO (O PLOT ACIMA EH FEITO SOBRE A DISSMILARIDADE => 1-COR)
MEDissThres = 0.15 # antonio 0.3 e brandão 0.25
# Plot the cut line into the dendrogram
abline(h=MEDissThres, col = "red")
# Call an automatic merging function
merge = mergeCloseModules(datExpr, dynamicColors, cutHeight = MEDissThres, verbose = 3)
# The merged module colors
mergedColors = merge$colors
# Eigengenes of the new merged modules:
mergedMEs = merge$newMEs
dev.off()

#PLOTA OS RESULTADOS DE AMBAS METODOLOGIAS
png(filename = paste0(file_path,"genedendro_0.15.png"), width=2000, height=1500, res = 300)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors),
                    c("Dynamic Tree Cut", "Merged dynamic"),
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
dev.off()


moduleColors = mergedColors
# Constrói os rótulos numéricos correspondente as cores
colorOrder = c("grey", standardColors(50));
moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;


bwnet = blockwiseModules(datExpr, maxBlockSize = 5000,
                         power = softPower, TOMType = networkType, minModuleSize = minModuleSize,
                         reassignThreshold = 0, mergeCutHeight = 0.25,
                         numericLabels = TRUE,
                         saveTOMs = FALSE, #or TRUE
                         saveTOMFileBase = paste0(file_path,"SpodopteraTOM-blockwise"),
                         verbose = 3)

# Carregando os resultados da análise single-block
#load(file = "Spodoptera-02-networkConstruction-auto.RData");
# Re-rotulando módulos blockwise

bwLabels = matchLabels(bwnet$colors, moduleLabels);

# Convertendo os rótulos em cores para plotagem
bwModuleColors = labels2colors(bwLabels)

# Plotando o dendograma e o as cores dos módulos embaixo para o bloco 1 (Substituir o número do bloco que você quer plotar em bwnet$dendrograms[[X]] e bwModuleColors[bwnet$blockGenes[[X]]])
png(filename = paste0(file_path,"Gene dendrogram and module colors.png"), width=2000, height=1500, res = 300)
plotDendroAndColors(bwnet$dendrograms[[1]], bwModuleColors[bwnet$blockGenes[[1]]],
                    "Module colors", main = "Gene dendrogram and module colors in block 1",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
dev.off()

png(filename = paste0(file_path,"Single block gene dendrogram.png"), width=2000, height=1500, res = 300)
#Plotar mais de um junto
plotDendroAndColors(geneTree,
                    cbind(moduleColors, bwModuleColors),
                    c("Single block", "2 blocks"),
                    main = "Single block gene dendrogram and module colors",
                    dendroLabels = FALSE, hang = 0.03,
                    addGuide = TRUE, guideHang = 0.05)
dev.off()

singleBlockMEs = moduleEigengenes(datExpr, moduleColors)$eigengenes;
blockwiseMEs = moduleEigengenes(datExpr, bwModuleColors)$eigengenes;

single2blockwise = match(names(singleBlockMEs), names(blockwiseMEs))
signif(diag(cor(blockwiseMEs[, single2blockwise], singleBlockMEs)), 3)

gc(verbose = FALSE)

# Definindo o número de genes e amostras
nGenes = ncol(datExpr);
nSamples = nrow(datExpr);
# Recalcular MEs com rótulos de cores
MEs0 = moduleEigengenes(datExpr, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);

# Mostrar correlações e seus p-valores
textMatrix =  paste(signif(moduleTraitCor, 2), "\n(",
                    signif(moduleTraitPvalue, 1), ")", sep = "");
dim(textMatrix) = dim(moduleTraitCor)
png(filename = paste0(file_path,"Module-trait relationships.png"), width=12, height=6, res = 500, units = 'in')
# par(mar = c(8, 4.5, 1, 1))
# Mostrar os valores de correlação em um heatmap plot
labeledHeatmap(Matrix = moduleTraitCor,
               xLabels = names(datTraits),
               yLabels = names(MEs),
               ySymbols = names(MEs),
               colorLabels = FALSE,
               colors = blueWhiteRed(50),
               textMatrix = textMatrix,
               setStdMargins = FALSE,
               cex.text = 0.15,
               zlim = c(-1,1),
               cex.lab.y = 0.3,
               cex.lab.x = 0.8,
               cex.lab = 0.5, xLabelsAngle = 25,
               naColor = "black",
               main = paste("Module-trait relationships"))
dev.off()

# Definir a variável Peso10dias contendo a coluna Peso10dias do datTrait
# Peso10dias = as.data.frame(datTraits$Peso10dias);
# names(Peso10dias) = "Peso10d"
# # nomes (cores) dos módulos
# modNames = substring(names(MEs), 3)
#
# geneModuleMembership = as.data.frame(cor(datExpr, MEs, use = "p"));
# MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));
#
# names(geneModuleMembership) = paste("MM", modNames, sep="");
# names(MMPvalue) = paste("p.MM", modNames, sep="");
#
# geneTraitSignificance = as.data.frame(cor(datExpr, Peso10dias, use = "p"));
# GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));
#
# names(geneTraitSignificance) = paste("GS.", names(Peso10dias), sep="");
# names(GSPvalue) = paste("p.GS.", names(Peso10dias), sep="");
#
# module = "greenyellow" #########################colocar cor do módulo para o plot
# column = match(module, modNames);
# moduleGenes = moduleColors==module;
#
# par(mfrow = c(1,1));
# verboseScatterplot(abs(geneModuleMembership[moduleGenes, column]),
#                    abs(geneTraitSignificance[moduleGenes, 1]),
#                    xlab = paste("Module Membership in", module, "module"),
#                    ylab = "Gene significance for Peso 10 dias",
#                    main = paste("Module membership vs. gene significance\n"),
#                    cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)
#
# #colnames(datExpr)
# colnames(datExpr)[moduleColors=="greenyellow"] ##########mostra os nomes dos genes dentro de cada módulo

# geneInfo0 = data.frame(EST = colnames(datExpr),
#                        moduleColor = moduleColors,
#                        geneTraitSignificance,
#                        GSPvalue)
#
#
# modOrder = order(-abs(cor(MEs, Peso10dias, use = "p")));
# for (mod in 1:ncol(geneModuleMembership))
# {
#     oldNames = names(geneInfo0)
#     geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]],
#                            MMPvalue[, modOrder[mod]]);
#     names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
#                          paste("p.MM.", modNames[modOrder[mod]], sep=""))
# }
# geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.Peso10d));
# geneInfo = geneInfo0[geneOrder, ]
# write.csv(geneInfo, file = "geneInfo.csv")

#################################################################################
######################Exportar rede no formato para Cytoscape

# Recalcular overlap topological, se necessário
#TOM = TOMsimilarityFromExpr(datExpr, power = 10);
# Selecionar módulos
#modules = c("brown", "red"); #############escolhe modulos que quer exportar para a rede
# Selecionar módulos dos genes
genes = colnames(datExpr)
inModule = is.finite(match(moduleColors, moduleColors)); ##### se quiser exportar só cores especificas, substitui o segundo modulecolors pelos modules de cima
modGenes = genes[inModule];
#modGenes = annot$gene_symbol[match(modProbes, annot$substanceBXH)];
# Selecionar o Overlap Topologico correspondente
modTOM = TOM[inModule, inModule];
dimnames(modTOM) = list(modGenes, modGenes)
gc(verbose = FALSE)
#########modTOMSignificantes = which(modTOM>0.1)
#####warnings()

####################Genes organizados pela importância dentro do módulo
genes = colnames(datExpr)
sum(is.na(genes))
# Deve retornar 0.

# Cria o dataframe de início
# geneInfo0 = data.frame(ESTs = genes,
#                        moduleColor = moduleColors,
#                        geneTraitSignificance,
#                        GSPvalue)
# # Ordena os módulos pela sua significância para um caracter Ex: Peso 10 dias
# modOrder = order(-abs(cor(MEs, Peso10dias, use = "p")));
# # Adiciona informação de membros do módulo na ordem escolhida
# for (mod in 1:ncol(geneModuleMembership))
# {
#     oldNames = names(geneInfo0)
#     geneInfo0 = data.frame(geneInfo0, geneModuleMembership[, modOrder[mod]],
#                            MMPvalue[, modOrder[mod]]);
#     names(geneInfo0) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
#                          paste("p.MM.", modNames[modOrder[mod]], sep=""))
# }
# # Ordena os genes na variavel geneinfo primeiro pela cor do módulo, depois pela geneTraitSignificance
# geneOrder = order(geneInfo0$moduleColor, -abs(geneInfo0$GS.Peso10d));
# geneInfo = geneInfo0[geneOrder, ]
#
# #escreve um arquivo com os valores ordenados
# write.csv(geneInfo, file = "geneInfo.csv")


#IMPRIME APENAS OS MODULOS DE INTERESSE, TEM Q SABER QUAL COR EH
# $ Choose interesting modules
# intModules = c("grey60", "brown", "blue", "magenta") # brown =>
# for (module in intModules)
# {
#     # Select module probes
#     modGenes = (moduleColors==module)
#     # Write them into a file
#     fileName = paste("LocusIDs-", module, ".txt", sep="")
#
#     write.table(as.data.frame(cbind(probes,modGenes)), file = paste(file_path, fileName, sep = "/"),
#                 row.names = TRUE, col.names = FALSE)
# }


###Step 6: exporting network

#NAO PRECISA RECALCULAR ISSO, A NAO SER Q QUEIRA COMECAR A PARTIR DAQUI
# Recalculate topological overlap
#TOM = TOMsimilarityFromExpr(datExpr, power = softPower);

# Read in the annotation file
#annot = read.csv(file = "GeneAnnotation.csv");


# SUPER IMPORTANTE PQ SOH GERA A REDE DESSE MODULO BROWN
# Select module
module = "blue"

# Select module probes
probes = colnames(datExpr)
inModule = (moduleColors==module)
modProbes = probes[inModule]
# Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule]
dimnames(modTOM) = list(modProbes, modProbes)
# Export the network into an edge list file VisANT can read
#vis = exportNetworkToVisANT(modTOM,
#  file = paste("VisANTInput-", module, ".txt", sep=""),
#  weighted = TRUE,
#  threshold = 0,
#  probeToGene = data.frame(annot$substanceBXH, annot$gene_symbol) )

# SUPER IMPORTANTE PQ SOH GERA A REDE DESSE MODULO BROWN e RED

# Select modules => "magenta", "brown", "blue", "purple" => modulos q contem os genes de interesse
# modules = c("grey60", "brown", "blue", "lightyellow")
# Select module probes

#modGenes = annot$gene_symbol[match(modProbes, annot$substanceBXH)];

#faz um sobconjunto da matrix TOM com apenas esses genes
# Select the corresponding Topological Overlap
modTOM = TOM[inModule, inModule]

#exporta para o cytoscape
cyt = exportNetworkToCytoscape(modTOM,
                               edgeFile = paste0(file_path, "CytoscapeInput-edges-", paste(module, collapse="-"), ".txt"),
                               nodeFile = paste0(file_path, "CytoscapeInput-nodes-", paste(module, collapse="-"), ".txt"),
                               weighted = TRUE,
                               threshold = 0,#abs(0.5+(0.5*0.85))**softPower, # abs(0.5+(0.5*0.85))**14
                               nodeNames = modProbes,
                               nodeAttr = moduleColors[inModule])

cyt = exportNetworkToCytoscape(modTOM,
                               edgeFile = paste0(file_path, "CytoscapeInput-edges-",
                                                 paste(module, collapse="-"), "with_threshold_",
                                                 abs(0.5+(0.5*0.85))**softPower, ".txt"),
                               nodeFile = paste0(file_path, "CytoscapeInput-nodes-",
                                                 paste(module, collapse="-"), "with_threshold_",
                                                 abs(0.5+(0.5*0.85))**softPower, ".txt"),
                               weighted = TRUE,
                               threshold = abs(0.5+(0.5*0.85))**softPower, # abs(0.5+(0.5*0.85))**14
                               nodeNames = modProbes,
                               nodeAttr = moduleColors[inModule])

network <- list(moduleColors=moduleColors, MEs=MEs)

try(network_km <- km2gcn::applykM2WGCNA(net.label="dummy",
                                    net.file=network,
                                    expr.data=datExpr,
                                    job.path = file_path,
                                    meg=0, net.type=networkType,
                                    plot.evolution=TRUE))

final_modules <- data.frame(network_km$moduleColors)

write.table(final_modules, file = paste0(file_path, 'gene_modules_km.tsv'),
            col.names = c("module"), sep = "\t", quote = FALSE)


restGenes= (dynamicColors != "grey")
diss1=1-TOMsimilarityFromExpr(datExpr[,restGenes], power = softPower, )

colnames(diss1) =rownames(diss1) =SubGeneNames[restGenes]
hier1=flashClust::flashClust(as.dist(diss1), method="average" )
plotDendroAndColors(hier1, dynamicColors[restGenes], "Dynamic Tree Cut", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = "Gene dendrogram and module colors")

#set the diagonal of the dissimilarity to NA
diag(diss1) = NA;

#Visualize the Tom plot. Raise the dissimilarity matrix to the power of 4 to bring out the module structure
TOMplot(diss1, hier1, as.character(dynamicColors[restGenes]))


module_colors= setdiff(unique(dynamicColors), "grey")
for (color in module_colors){
    module=SubGeneNames[which(dynamicColors==color)]
    write.table(module, paste("module_",color, ".txt",sep=""), sep="\t", row.names=FALSE, col.names=FALSE,quote=FALSE)
}

module.order <- unlist(tapply(1:ncol(datExpr),as.factor(dynamicColors),I))
m<-t(t(datExpr[,module.order])/apply(datExpr[,module.order],2,max))
heatmap(t(m),zlim=c(0,1),col=gray.colors(100),Rowv=NA,Colv=NA,labRow=NA,scale="none",RowSideColors=dynamicColors[module.order])

# Quantify module similarity by eigengene correlation. Eigengenes: Module representatives

MEList = moduleEigengenes(datExpr, colors = dynamicColors)
MEs = MEList$eigengenes
plotEigengeneNetworks(MEs, "", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2))


gc(verbose = FALSE)
message("\nDone!")

# dissTOM =TOMdist(adjacency)
# #hierarchical clustering
# geneTree = flashClust::flashClust(as.dist(dissTOM),method="average")
#
# minModuleSize = 30;
# # Module identification using dynamic tree cut:
# dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
#                             deepSplit = 2, pamRespectsDendro = FALSE,
#                             minClusterSize = minModuleSize)
# #table(dynamicMods)
#
#
# # LISTS THE SIZE OF THE MODULES (42 MODULES WERE FOUND)
# # Convert numeric lables into colors
# dynamicColors = labels2colors(dynamicMods)
#
# diag(dissTOM) = NA
# # Transform dissTOM with a power to enhance visibility
# png(filename = paste0(file_path,"TOM_plot.png"), width=2000, height=1500, res = 300)
# TOMplot(dissim=dissTOM^7,dendro=geneTree,colors=dynamicColors, main = "Network heatmap plot, all genes")
# dev.off()
